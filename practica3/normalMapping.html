<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Normal mapping</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                font-family: Monospace;
                background-color: #707080;
                margin: 0px;
                overflow: hidden;
            }
        </style>
    </head>
    <body>
    <div id="container">
        <div id="controlBar" style="text-align: center;">
            <input type="file" id="meshInputFile" style="display: none;" onchange="loadFile(this.files[0])">
            <input type="button" id="meshInputButton" value="Select OBJ File" onclick="document.getElementById('meshInputFile').click()">
            <input type="file" id="texInputFile" style="display: none;" onchange="loadTexture(this.files[0], 'diffuseTexture')">
            <input type="button" id="texInputButton" value="Select Texture File" onclick="document.getElementById('texInputFile').click()">
            <input type="file" id="normalInputFile" style="display: none;" onchange="loadTexture(this.files[0], 'normalMap')">
            <input type="button" id="normalInputButton" value="Select Normal Map File" onclick="document.getElementById('normalInputFile').click()">
            <label><input type="checkbox" id="showAxesCheckbox" onchange="toggleAxes(this.checked)" checked="true">Show Axes</label>
            <label><input type="checkbox" id="showWireframeCheckbox" onchange="toggleWireframe(this.checked)">Show Wireframe</label>
            <label><input type="checkbox" id="showNormalsCheckbox" onchange="toggleNormals(this.checked)">Show Normals</label>
            <label><input type="checkbox" id="fixLightsToCameraCheckbox" onchange="toggleFixLightsToCamera(this.checked)">Fix lights to camera</label>
            <br>
            Normal length:
            <input type="range" id="normalLengthRange" min="0.02" max="0.5" step="0.02" value="0.3" oninput="setNormalLength(this.value)">
            Exposure:
            <input type="range" id="exposureRange" min="10.0" max="18.0" step="0.5" value="14.0" oninput="setUniformLog('exposure', this.value)">
            Roughness:
            <input type="range" id="roughnessRange" min="-16.0" max="0.0" step="0.5" value="-8.0" oninput="setUniformLog('roughness', this.value)">
            Bumpiness:
            <input type="range" id="bumpinessRange" min="-4.0" max="4.0" step="0.25" value="0.0" oninput="setUniformLog('bumpiness', this.value)">
            <br>
            Left click + drag to orbit. Right click + drag to pan. Scroll to zoom.
        </div>
    </div>

        <script src="js/three.min.js"></script>
        <script src="js/BufferGeometryUtils.js"></script>
        <!-- <script src="http://cdnjs.cloudflare.com/ajax/libs/three.js/r84/three.min.js"></script> -->
        <script src="js/Detector.js"></script>
        <script src="js/OrbitControls.js"></script>
        <script src="js/OBJLoader.js"></script>
<!-----------------------------------------------------------------------------
        VERTEX SHADER
------------------------------------------------------------------------------>
        <script id="vertexShader" type="x-shader/x-vertex">
// = object.matrixWorld
// uniform mat4 modelMatrix;

// = camera.matrixWorldInverse * object.matrixWorld
// uniform mat4 modelViewMatrix;

// = camera.projectionMatrix
// uniform mat4 projectionMatrix;

// = camera.matrixWorldInverse
// uniform mat4 viewMatrix;

// = inverse transpose of modelViewMatrix
// uniform mat3 normalMatrix;

// = camera position in world space
// uniform vec3 cameraPosition;

// RenderMesh Input
// attribute vec3 position;
// attribute vec3 normal;
// attribute vec2 uv;

attribute vec3 tangent;
attribute vec3 tangent2;

// Declarar aqui varying necesarias para la resolucion
// Para phong:
varying vec2 vUv;
varying vec4 vPosition; // posicion del vertice en espacio de la camara

// Normal (espacio de la cam):
varying vec3 vNormal;
// Tangentes en espacio de la camara:
varying vec3 vTangent;
varying vec3 vTangent2;

void main() {

	// Calculos para dar valor a las varying aqui

    // El vertex shader debe proporcionar gl_Position (en espacio homogeneo o de pantalla)
    // Transformar posiciones a espacio homogeneo
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    vPosition = modelViewMatrix * vec4(position, 1.0);;
    // Necesitamos la base (del espacio tangente) en espacio de la camara:
    vNormal = normalize(normalMatrix* normal);
    vTangent = normalize(normalMatrix * tangent);
    vTangent2 = normalize(normalMatrix * tangent2);
    // vTangent = normalize( tangent);
    // vTangent2 = normalize(tangent2);
    vUv = uv;
}
        </script>
<!-----------------------------------------------------------------------------
        FRAGMENT SHADER
------------------------------------------------------------------------------>
        <script id="fragmentShader" type="x-shader/x-fragment">

// Intensidad (color) y posicion de las luces.
// NUM_LIGHTS es una constante que contiene el numero de luces.
uniform vec3 lightColors[ NUM_LIGHTS ];
uniform vec3 lightPositions[ NUM_LIGHTS ]; // in view coordinates

// Exposicion; no tendreis que hacer nada con ella
// Su valor es controlado por un slider
uniform float exposure;

// Roughness o rugosidad: tal y como se define aqui, roughness = 1.0 / m
// Su valor es controlado por un slider
uniform float roughness;

// Bumpiness (mas informacion sobre ella en el guion)
// Su valor es controlado por un slider
uniform float bumpiness;

// Samplers utilizados para acceder a las texturas (difusa y normal map)
// (ambas se cargan con el boton correspondiente del interfaz)
uniform sampler2D diffuseTexture;
uniform sampler2D normalMap;

// Declarar aqui varying necesarias para la resolucion
// Para phong:
varying vec2 vUv;
varying vec4 vPosition; // posicion del vertice en espacio de la camara

// Normal original del vertice (espacio de la cam):
varying vec3 vNormal;
// Tangentes en espacio de la camara:
varying vec3 vTangent;
varying vec3 vTangent2;

vec3 to_sRGB(vec3 c) { return pow(c, vec3(1.0/2.2)); }
vec3 from_sRGB(vec3 c) { return pow(c, vec3(2.2)); }

vec3 bisectriz(vec3 v, vec3 w) {
  return normalize(normalize(v) + normalize(w));
}

// Devuelve el color con shading de phong del fragmento
vec3 phong(vec3 n) {
  vec3 col = vec3(0.); // Color final
  vec3 v = normalize(-vPosition.xyz); // punto a camara
  vec3 cdif = from_sRGB(texture2D(diffuseTexture, vUv).rgb); // Coef difuso, textura
  vec3 cspec = vec3(1.); // Coef especular, 1
  for (int i = 0; i < NUM_LIGHTS; i++) { // Contribucion de cada luz
    vec3 l = lightPositions[i]-vPosition.xyz; // Vector a la luz
    float r = length(l); // Dist a la luz
    l = normalize(l);
    float dotnl = dot(n,l); // escalar normal, luz
    if (dotnl > 0.) { // dotnl debe ser mayor que 0 (y si es 0, c es 0)
      vec3 h = bisectriz(v,l); // h, entre camara y luz
      float dotnh = dot(n,h);
      if (dotnh >= 0.) { // dotnh puede ser 0
        col += (cdif+cspec*pow(dotnh,1./roughness))
            * lightColors[i] * dotnl / (r*r);
      }
    }
  }
  return col;
}


// No esta definida en esta version de glsl..
mat3 transpose(mat3 m) {
  mat3 r;
  for (int i = 0; i<3; i++) {
    for (int j = 0; j<3; j++) {
      r[i][j] = m[j][i];
    }
  }
  if (r==m) return mat3(0.);
  return r;
}
// No esta definida en esta version de glsl..
mat4 transpose(mat4 m) {
  mat4 r;
  for (int i = 0; i<4; i++) {
    for (int j = 0; j<4; j++) {
      r[i][j] = m[j][i];
    }
  }
  return r;
}

// Devuelve la matriz de cambio de base del espacio tangente al de la camara
mat4 getMatrixTangentToCamera() {
  return transpose(mat4(vec4(vNormal,0.), vec4(vTangent,0.), vec4(vTangent2,0.),vec4(0.,0.,0.,1.)));
}

// Devuelve la matriz de cambio de base del espacio tangente al de la camara
mat3 getMat3TangentToCamera() {
  // Inversa transpuesta. Como inv(M)=transpuesta(M) en este caso,
  // inv(transpuesta(M)) = inv(inv(M)) = M
  return (mat3(vTangent,vTangent2,vNormal));
}

// Devuelve la normal del mapa de normales en espacio de la camara:
vec3 normalFromUV(vec2 uv) {
  vec3 n = normalize(2.0*((texture2D(normalMap, uv).rgb)-0.5)); // -0.5 para que puedan ser negativas
  n.y = -n.y; // cambiar de formato de DirectX
  n.xy = n.xy * bumpiness; // Mas relieve
  mat3 matTangentToCam = getMat3TangentToCamera();
  return matTangentToCam*normalize(n);

}


void main() {
    // Normal del mapa:
    vec3 n = normalFromUV(vUv);
    // Shading con phong con esa normal:
    vec3 finalColor = phong(n);
    // Solo se sombrea si esta "de cara", si no se le da un color fijo
    if (gl_FrontFacing) {
        gl_FragColor = vec4(to_sRGB(finalColor * exposure), 1.0);
        //gl_FragColor = vec4(to_sRGB(0.5*n+0.5), 1.0);
    } else {
        gl_FragColor = vec4(170.0/255.0, 160.0/255.0, 0.0, 1.0);
    }

}
        </script>
<!-----------------------------------------------------------------------------
        END SHADERS
------------------------------------------------------------------------------>
        <script src="js/A4Common.js"></script>
        <script>
            commonInit();
            init();
            animate();

            function init() {
                defaultTextureTarget = 'diffuseTexture';
                meshMaterial.uniforms.diffuseTexture = { type: 't', value: null };
                meshMaterial.uniforms.normalMap = { type: 't', value: null };

                addLight(new THREE.Vector3(50, 50, 100), new THREE.Vector3(0.8, 0.8, 0.8));
                addLight(new THREE.Vector3(-50, -50, -50), new THREE.Vector3(0.5, 0.5, 0.6));

                document.getElementById('roughnessRange').oninput();
                document.getElementById('bumpinessRange').oninput();
            }
        </script>
    </body>
</html>
